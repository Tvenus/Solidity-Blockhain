// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.5.16;

/// @title VulnerableGuarded
/// @author Joe Tinotenda
/// @dev This contract demonstrates a simple balance management with reentrancy protection.
contract VulnerableGuarded {
	/// @notice Mapping that keeps track of each address's balance.
	/// @dev Key is the address, value is the balance.
	mapping(address => uint) public balance;

	/// @notice Lock to protect against reentrancy attacks.
	/// @dev It's a simple boolean lock, set to true when the function is under execution.
	bool public reentrancyLock;

	/// @notice Allows the user to deposit funds into the contract.
	/// @dev When depositing, a reentrancy lock gets activated to prevent recursive calls and implications of reentrancy attacks.
	function deposit() public payable {
		require(
			!reentrancyLock,
			"Reentrancy protection is activated. Aborted to prevent attack."
		);
		reentrancyLock = true;
		balance[msg.sender] += msg.value;
		reentrancyLock = false;
	}

	/// @notice Allows the user to withdraw funds from the contract.
	/// @dev The function allows a payable withdrawal and updates the user's balance.
	/// @return sendStatus The status of the transfer function.
	function withdraw() public payable returns (bool sendStatus) {
		require(
			balance[msg.sender] >= msg.value,
			"Insufficient balance. Aborted to prevent underflow."
		);
		balance[msg.sender] -= msg.value;
		(bool success, ) = payable(msg.sender).call{ value: msg.value }("");
		require(success, "Transfer failed. Process aborted.");
		return success;
	}
}
